
func HandleEndOfCopyStream(ctx context.Context, stream *StreamCtl, conn *pgconn.PgConn, blockpos uint64, stoppos *uint64) error {

	if stream.StillSending {

		// Close any local WAL files
		if err := stream.CloseWalfile(pglogrepl.LSN(blockpos)); err != nil {
			log.Printf("failed to close WAL file: %v", err)
			return err
		}

		// pglogrepl doesn't use PGresult â€” so we ReceiveMessage
		msg, err := conn.ReceiveMessage(ctx)
		if err != nil {
			return err
		}

		switch m := msg.(type) {
		case *pgproto3.CopyDone:
			if _, err := pglogrepl.SendStandbyCopyDone(ctx, conn); err != nil {
				return fmt.Errorf("failed to send client CopyDone: %w", err)
			}
			msg, err = conn.ReceiveMessage(ctx)
			if err != nil {
				return err
			}
		case *pgproto3.CommandComplete:
			// Possibly after CopyDone
			log.Printf("received CommandComplete: %v", m.CommandTag)
		case *pgproto3.ErrorResponse:
			return errors.New("server error: " + m.Message)
		default:
			log.Printf("unexpected message type: %T", m)
		}

		stream.StillSending = false
	}

	// Update stoppos
	*stoppos = blockpos

	return nil
}
