func CopyStreamReceive(conn *pgconn.PgConn, timeout time.Duration, stopChan <-chan struct{}) (data []byte, result int, err error) {
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()

	// Create a derived ctx that cancels if stopChan closes
	ctx, stopCancel := context.WithCancel(ctx)
	defer stopCancel()

	go func() {
		select {
		case <-stopChan:
			stopCancel()
		case <-ctx.Done():
		}
	}()

	msg, err := conn.ReceiveMessage(ctx)
	if err != nil {
		if pgconn.Timeout(err) || ctx.Err() != nil {
			return nil, 0, nil
		}
		return nil, -1, err
	}

	switch m := msg.(type) {
	case *pgproto3.CopyData:
		return m.Data, len(m.Data), nil
	case *pgproto3.CopyDone:
		return nil, -2, nil
	case *pgproto3.ErrorResponse:
		return nil, -1, pgconn.ErrorResponseToPgError(m)
	default:
		return nil, 0, nil
	}
}

