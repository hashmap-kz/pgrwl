func ProcessKeepaliveMsg(ctx context.Context,
	conn *pgconn.PgConn,
	stream *StreamCtl,
	keepalive pglogrepl.PrimaryKeepaliveMessage,
	blockPos pglogrepl.LSN,
	lastStatus *time.Time,
) error {
	slog.Info("ProcessKeepaliveMsg")

	if keepalive.ReplyRequested && stream.StillSending {
		// If a valid flush location needs to be reported, and WAL file exists
		if stream.ReportFlushPosition && stream.LastFlushPosition < blockPos && stream.walfile != nil {
			if err := stream.SyncWalFile(); err != nil {
				return fmt.Errorf("could not fsync WAL file: %w", err)
			}
			stream.LastFlushPosition = blockPos
		}

		now := time.Now()
		if err := sendFeedback(ctx, stream, conn, blockPos, now, false); err != nil {
			return fmt.Errorf("failed to send feedback in keepalive: %w", err)
		}
		*lastStatus = now
	}

	return nil
}

//////////////////////////////////////////////////////////////////////////

		  case *pgproto3.CopyData:
			switch m.Data[0] {
			case pglogrepl.PrimaryKeepaliveMessageByteID:
				// v0
				// pkm, err := pglogrepl.ParsePrimaryKeepaliveMessage(m.Data[1:])
				// if err != nil {
				// 	return fmt.Errorf("parse keepalive failed: %w", err)
				// }
				// if pkm.ReplyRequested {
				// 	if err := sendFeedback(ctx, stream, conn, blockPos, time.Now(), false); err != nil {
				// 		return fmt.Errorf("send feedback on reply requested failed: %w", err)
				// 	}
				// 	lastStatus = time.Now()
				// }

				// v1
				pkm, err := pglogrepl.ParsePrimaryKeepaliveMessage(m.Data[1:])
				if err != nil {
					return fmt.Errorf("parse keepalive failed: %w", err)
				}
				if err := ProcessKeepaliveMsg(ctx, conn, stream, pkm, blockPos, &lastStatus); err != nil {
					return fmt.Errorf("process keepalive failed: %w", err)
				}

