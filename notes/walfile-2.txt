package xlog

import (
	"fmt"
	"os"
	"path/filepath"
)

type WalWriter struct {
	baseDir string
	sync    bool
}

type WalFile struct {
	fullPath    string
	tmpPath     string
	fd          *os.File
	needsRename bool
}

// NewWalWriter creates a new WAL writer for a given base directory
func NewWalWriter(baseDir string, sync bool) *WalWriter {
	return &WalWriter{
		baseDir: baseDir,
		sync:    sync,
	}
}

// Open a new WAL file for writing (maybe with temp suffix)
func (w *WalWriter) Open(pathname string, tempSuffix string, padToSize int64) (*WalFile, error) {
	finalName := pathname
	if tempSuffix != "" {
		finalName += tempSuffix
	}
	fullPath := filepath.Join(w.baseDir, finalName)

	// open file
	fd, err := os.OpenFile(fullPath, os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0o660)
	if err != nil {
		return nil, fmt.Errorf("could not create WAL file %s: %w", fullPath, err)
	}

	// truncate to requested size
	if padToSize > 0 {
		if err := fd.Truncate(padToSize); err != nil {
			_ = fd.Close() // TODO:log:fclose()
			return nil, fmt.Errorf("could not preallocate WAL file %s: %w", fullPath, err)
		}
	}

	// fsync file and its directory
	if w.sync {
		err := fd.Sync()
		if err != nil {
			_ = fd.Close() // TODO:log:fclose()
			return nil, fmt.Errorf("cannot sync WAL file %s: %w", fullPath, err)
		}
		err = FsyncFname(w.baseDir)
		if err != nil {
			_ = fd.Close() // TODO:log:fclose()
			return nil, fmt.Errorf("cannot sync WAL file basedir %s: %w", w.baseDir, err)
		}
	}

	return &WalFile{
		fullPath:    filepath.Join(w.baseDir, pathname),
		tmpPath:     fullPath,
		fd:          fd,
		needsRename: tempSuffix != "",
	}, nil
}

// Write to WAL file
func (wf *WalFile) Write(buf []byte) (int, error) {
	return wf.fd.Write(buf)
}

// Sync WAL file to disk
func (wf *WalFile) Sync() error {
	return wf.fd.Sync()
}

// Close WAL file (optionally rename if tempSuffix was used)
func (wf *WalFile) Close(w *WalWriter, unlink bool) error {
	defer wf.fd.Close()

	if unlink {
		return os.Remove(wf.tmpPath)
	}
	if wf.needsRename {
		return os.Rename(wf.tmpPath, wf.fullPath)
	}
	if w.sync {
		return fsyncParentDir(wf.fullPath)
	}
	return nil
}

func fsyncParentDir(path string) error {
	dir := filepath.Dir(path)
	d, err := os.Open(dir)
	if err != nil {
		return err
	}
	defer d.Close()
	return d.Sync()
}

func (w *WalWriter) Exists(pathname string) bool {
	_, err := os.Stat(filepath.Join(w.baseDir, pathname))
	return err == nil
}

func (w *WalWriter) FileSize(pathname string) (int64, error) {
	fi, err := os.Stat(filepath.Join(w.baseDir, pathname))
	if err != nil {
		return 0, err
	}
	return fi.Size(), nil
}
