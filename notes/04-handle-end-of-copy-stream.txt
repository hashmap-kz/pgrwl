import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/jackc/pgproto3/v2"
	"github.com/jackc/pgconn"
)

// Assume stillSending is a *atomic.Bool

func HandleEndOfCopyStream(
	ctx context.Context,
	conn *pgconn.PgConn,
	stream *StreamCtl,
	blockPos pglogrepl.LSN,
	stopPos *pglogrepl.LSN,
	stillSending *atomic.Bool,
) error {
	// 1. First server result
	msg, err := conn.ReceiveMessage(ctx)
	if err != nil {
		return fmt.Errorf("failed to receive server result: %w", err)
	}

	// 2. If still sending, close the WAL file and send CopyDone if needed
	if stillSending.Load() {
		if err := closeWalFile(stream, blockPos); err != nil {
			return fmt.Errorf("failed to close wal file: %w", err)
		}

		switch m := msg.(type) {
		case *pgproto3.CopyInResponse:
			// Server expects CopyDone, send it
			if err := conn.Frontend().Send(&pgproto3.CopyDone{}); err != nil {
				return fmt.Errorf("could not send CopyDone: %w", err)
			}
			if err := conn.Frontend().Flush(); err != nil {
				return fmt.Errorf("could not flush CopyDone: %w", err)
			}

			// Get another server result after sending CopyDone
			msg, err = conn.ReceiveMessage(ctx)
			if err != nil {
				return fmt.Errorf("failed to receive after CopyDone: %w", err)
			}
		case *pgproto3.ErrorResponse:
			return pgconn.ErrorResponseToPgError(m)
		case *pgproto3.ReadyForQuery:
			// OK: already finished
		default:
			// Unexpected type
			return fmt.Errorf("unexpected server message after CopyStream end: %T", m)
		}

		stillSending.Store(false)
	}

	// 3. Set stop position
	*stopPos = blockPos

	// 4. Done
	return nil
}
