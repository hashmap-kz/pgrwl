package main

import (
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"time"

	"github.com/hashmap-kz/pgrwl/config"
)

func main() {
	// usage: go generate ./config

	code := GenerateMergeFuncCode(config.Config{}, "Config")

	// Add header (package + imports)
	header := `// Code generated by genmerge; DO NOT EDIT.

package config

import (
	"os"
	"strconv"
)

`
	if strings.Contains(code, "time.ParseDuration") {
		header = `// Code generated by genmerge; DO NOT EDIT.

package config

import (
	"os"
	"strconv"
	"time"
)

`
	}

	// Format using go/format
	formatted, err := format.Source([]byte(header + code))
	if err != nil {
		log.Fatal(err)
	}

	// Write to output file
	out := "config_merge_env.go"
	if err := os.MkdirAll(filepath.Dir(out), 0o755); err != nil {
		log.Fatal(err)
	}
	if err := os.WriteFile(out, formatted, 0o644); err != nil {
		log.Fatal(err)
	}
	fmt.Println("Generated:", out)
}

func GenerateMergeFuncCode(structVal any, structName string) string {
	var b strings.Builder
	t := reflect.TypeOf(structVal)

	b.WriteString(fmt.Sprintf("func mergeEnvIfUnset(cfg *%s) {\n", structName))
	b.WriteString(`if cfg == nil {
			return
		}
`)

	for i := 0; i < t.NumField(); i++ {
		f := t.Field(i)
		fieldName := f.Name
		envKey := f.Tag.Get("json")
		if envKey == "" {
			continue
		}

		switch {
		case f.Type == reflect.TypeOf(time.Duration(0)):
			b.WriteString(fmt.Sprintf(`if cfg.%[1]s == 0 {
			if v, ok := os.LookupEnv("%[2]s"); ok && v != "" {
				if d, err := time.ParseDuration(v); err == nil {
					cfg.%[1]s = d
				}
			}
		}
`, fieldName, envKey))

		case f.Type.Kind() == reflect.String:
			b.WriteString(fmt.Sprintf(`if cfg.%[1]s == "" {
			if v, ok := os.LookupEnv("%[2]s"); ok && v != "" {
				cfg.%[1]s = v
			}
		}
`, fieldName, envKey))

		case f.Type.Kind() == reflect.Int:
			b.WriteString(fmt.Sprintf(`if cfg.%[1]s == 0 {
			if v, ok := os.LookupEnv("%[2]s"); ok && v != "" {
				if i, err := strconv.Atoi(v); err == nil {
					cfg.%[1]s = i
				}
			}
		}
`, fieldName, envKey))

		case f.Type.Kind() == reflect.Bool:
			b.WriteString(fmt.Sprintf(`if !cfg.%[1]s {
			if v, ok := os.LookupEnv("%[2]s"); ok && v != "" {
				if b, err := strconv.ParseBool(v); err == nil {
					cfg.%[1]s = b
				}
			}
		}
`, fieldName, envKey))
		}
	}

	b.WriteString("}\n")

	// Format the generated code
	src := b.String()
	formatted, err := format.Source([]byte(src))
	if err != nil {
		// fallback to unformatted version if broken (helpful for debugging)
		fmt.Printf(`
// ERROR in format+
%s
// ERROR in format-
`, src)
		log.Fatal(err)
	}

	return string(formatted)
}
